{"version":3,"file":"SimulationWorker-CKl5zPEe.js","sources":["../src/core/workers/SharedMemory.ts","../src/core/workers/SimulationWorker.ts"],"sourcesContent":["/**\r\n * Helper centralisé pour le mapping du SharedArrayBuffer.\r\n * Définit l'ordre des vues et expose une fonction utilitaire pour créer les TypedArray.\r\n *\r\n * Ajouts :\r\n * - Zone de contrôle (Int32Array) placée au début du buffer pour la synchronisation\r\n *   inter-threads (phase, version, etc.).\r\n * - Export `SYNC_FLAGS` : indices dans la zone de contrôle (ex: PHASE = position 0).\r\n *\r\n * Remarque : la zone de contrôle est volontairement minimale (2 Int32) pour garder\r\n * les allocations faibles et l'alignement correct pour Atomics.\r\n */\r\n\r\n/**\r\n * Nombre d'éléments Int32 réservés pour la zone de contrôle.\r\n * Index 0 = PHASE, Index 1 = VERSION (ou usage futur).\r\n */\r\nexport const CONTROL_INT32_LENGTH = 2;\r\n\r\n/**\r\n * Indices (positions) dans la zone de contrôle Int32Array.\r\n * Utiliser `Atomics` sur la vue `control` avec ces indices.\r\n */\r\nexport const SYNC_FLAGS = {\r\n    PHASE: 0,\r\n    VERSION: 1,\r\n} as const;\r\n\r\nexport const BYTES_PER_UNIT =\r\n    4 * 3 + // posX,posY,posZ -> 3 * Float32 (3 * 4 bytes)\r\n    4 +     // rotation -> Float32\r\n    1 +     // type -> Uint8\r\n    1 +     // owner -> Uint8\r\n    1;      // active -> Uint8\r\n\r\nexport type SharedViews = {\r\n    // zone de contrôle (Int32Array) utilisée pour Atomics (phase/version...)\r\n    control: Int32Array;\r\n    posX: Float32Array;\r\n    posY: Float32Array;\r\n    posZ: Float32Array;\r\n    rotation: Float32Array;\r\n    type: Uint8Array;\r\n    owner: Uint8Array;\r\n    active: Uint8Array;\r\n};\r\n\r\n/**\r\n * Mappe le SharedArrayBuffer en vues typées.\r\n * La zone de contrôle est placée en tout début de buffer (offset 0).\r\n */\r\nexport function createViews(buffer: SharedArrayBuffer, maxUnits: number): SharedViews {\r\n    // control zone at the start (Int32Array)\r\n    const control = new Int32Array(buffer, 0, CONTROL_INT32_LENGTH);\r\n\r\n    // offset in bytes after control zone\r\n    let offset = CONTROL_INT32_LENGTH * 4;\r\n\r\n    const posX = new Float32Array(buffer, offset, maxUnits);\r\n    offset += maxUnits * 4;\r\n\r\n    const posY = new Float32Array(buffer, offset, maxUnits);\r\n    offset += maxUnits * 4;\r\n\r\n    const posZ = new Float32Array(buffer, offset, maxUnits);\r\n    offset += maxUnits * 4;\r\n\r\n    const rotation = new Float32Array(buffer, offset, maxUnits);\r\n    offset += maxUnits * 4;\r\n\r\n    const type = new Uint8Array(buffer, offset, maxUnits);\r\n    offset += maxUnits;\r\n\r\n    const owner = new Uint8Array(buffer, offset, maxUnits);\r\n    offset += maxUnits;\r\n\r\n    const active = new Uint8Array(buffer, offset, maxUnits);\r\n\r\n    return { control, posX, posY, posZ, rotation, type, owner, active };\r\n}\r\n","/**\r\n * Worker de simulation gérant la logique des unités en arrière-plan.\r\n * Reçoit un SharedArrayBuffer pour manipuler les données directement.\r\n *\r\n * Ajouts :\r\n * - Utilisation d'une zone de contrôle Int32 (views.control) pour signaler\r\n *   les phases d'écriture via Atomics afin d'éviter les races avec le main thread.\r\n * - Gestion minimale des erreurs avec postMessage({ type: 'ERROR', message }).\r\n *\r\n * Notes:\r\n * - `requestAnimationFrame` n'est pas garanti dans les workers; on utilise `setInterval`.\r\n * - Le mapping des vues est centralisé dans `SharedMemory.createViews`.\r\n */\r\n\r\nimport { createViews, SYNC_FLAGS } from './SharedMemory';\r\n\r\nlet buffer: SharedArrayBuffer | null = null;\r\nlet maxUnits = 0;\r\nlet views: ReturnType<typeof createViews> | null = null;\r\n\r\n// Utiliser ReturnType pour gérer la différence Node/Browser\r\nlet tickHandle: ReturnType<typeof setInterval> | null = null;\r\n\r\nself.onmessage = (e: MessageEvent) => {\r\n    const { type, data } = e.data;\r\n    // eslint-disable-next-line no-console\r\n    console.log('[SimulationWorker] Message reçu:', type);\r\n\r\n    if (type === 'INIT') {\r\n        try {\r\n            buffer = data.buffer;\r\n            maxUnits = data.maxUnits;\r\n\r\n            if (!buffer || maxUnits <= 0) {\r\n                postMessage({ type: 'ERROR', message: 'Invalid INIT payload' });\r\n                return;\r\n            }\r\n\r\n            // Créer les vues en accord avec MemoryManager (inclut `control`)\r\n            views = createViews(buffer as SharedArrayBuffer, maxUnits);\r\n\r\n            // Initialiser la zone de contrôle (phase READY = 1)\r\n            // : évite que le main thread interprète des valeurs anciennes\r\n            Atomics.store(views.control, SYNC_FLAGS.PHASE, 1);\r\n\r\n            console.log('[SimulationWorker] Initialisé avec', maxUnits, 'unités');\r\n\r\n            // Accuser réception de l'init et indiquer que le worker est prêt\r\n            postMessage({ type: 'INIT_ACK', data: { maxUnits } });\r\n            postMessage({ type: 'READY' });\r\n\r\n            // Lancement de la boucle de simulation (approximativement 60 FPS)\r\n            if (tickHandle !== null) clearInterval(tickHandle);\r\n            const fps = 60;\r\n            tickHandle = setInterval(() => simulate(1 / fps), Math.floor(1000 / fps));\r\n        } catch (err: any) {\r\n            postMessage({ type: 'ERROR', message: String(err) });\r\n        }\r\n    }\r\n};\r\n\r\nfunction simulate(dt: number) {\r\n    // dt conservé pour future logique de simulation (intégration vitesse / intégration physique).\r\n    void dt;\r\n    if (!views || !maxUnits) return;\r\n\r\n    try {\r\n        // Indiquer aux lecteurs qu'on passe en phase d'écriture\r\n        Atomics.store(views.control, SYNC_FLAGS.PHASE, 2); // WRITING\r\n\r\n        // Exemple minimal: on parcourt les unités actives.\r\n        const { active } = views;\r\n\r\n        for (let i = 0; i < maxUnits; i++) {\r\n            if (active[i] === 1) {\r\n                // TODO: implémenter logique de simulation (mouvement, collisions...)\r\n            }\r\n        }\r\n\r\n        // Écriture terminée — passer en phase READY\r\n        Atomics.store(views.control, SYNC_FLAGS.PHASE, 1); // READY\r\n    } catch (err: any) {\r\n        // Signalement d'erreur au main thread\r\n        postMessage({ type: 'ERROR', message: String(err) });\r\n        // Optionnel: stopper la boucle en cas d'erreur critique\r\n        if (tickHandle !== null) {\r\n            clearInterval(tickHandle);\r\n            tickHandle = null;\r\n        }\r\n    }\r\n}\r\n\r\n"],"names":["SYNC_FLAGS","createViews","buffer","maxUnits","control","offset","posX","posY","posZ","rotation","type","owner","active","views","tickHandle","e","data","fps","simulate","err","dt","i"],"mappings":"yBAuBO,MAAMA,EAAa,CACtB,MAAO,EACP,QAAS,CACb,EAyBO,SAASC,EAAYC,EAA2BC,EAA+B,CAElF,MAAMC,EAAU,IAAI,WAAWF,EAAQ,EAAG,CAAoB,EAG9D,IAAIG,EAAS,EAAuB,EAEpC,MAAMC,EAAO,IAAI,aAAaJ,EAAQG,EAAQF,CAAQ,EACtDE,GAAUF,EAAW,EAErB,MAAMI,EAAO,IAAI,aAAaL,EAAQG,EAAQF,CAAQ,EACtDE,GAAUF,EAAW,EAErB,MAAMK,EAAO,IAAI,aAAaN,EAAQG,EAAQF,CAAQ,EACtDE,GAAUF,EAAW,EAErB,MAAMM,EAAW,IAAI,aAAaP,EAAQG,EAAQF,CAAQ,EAC1DE,GAAUF,EAAW,EAErB,MAAMO,EAAO,IAAI,WAAWR,EAAQG,EAAQF,CAAQ,EACpDE,GAAUF,EAEV,MAAMQ,EAAQ,IAAI,WAAWT,EAAQG,EAAQF,CAAQ,EACrDE,GAAUF,EAEV,MAAMS,EAAS,IAAI,WAAWV,EAAQG,EAAQF,CAAQ,EAEtD,MAAO,CAAE,QAAAC,EAAS,KAAAE,EAAM,KAAAC,EAAM,KAAAC,EAAM,SAAAC,EAAU,KAAAC,EAAM,MAAAC,EAAO,OAAAC,CAAA,CAC/D,CC/DA,IAAIV,EAAmC,KACnCC,EAAW,EACXU,EAA+C,KAG/CC,EAAoD,KAExD,KAAK,UAAaC,GAAoB,CAClC,KAAM,CAAE,KAAAL,EAAM,KAAAM,CAAA,EAASD,EAAE,KAIzB,GAFA,QAAQ,IAAI,mCAAoCL,CAAI,EAEhDA,IAAS,OACT,GAAI,CAIA,GAHAR,EAASc,EAAK,OACdb,EAAWa,EAAK,SAEZ,CAACd,GAAUC,GAAY,EAAG,CAC1B,YAAY,CAAE,KAAM,QAAS,QAAS,uBAAwB,EAC9D,MACJ,CAGAU,EAAQZ,EAAYC,EAA6BC,CAAQ,EAIzD,QAAQ,MAAMU,EAAM,QAASb,EAAW,MAAO,CAAC,EAEhD,QAAQ,IAAI,qCAAsCG,EAAU,QAAQ,EAGpE,YAAY,CAAE,KAAM,WAAY,KAAM,CAAE,SAAAA,CAAA,EAAY,EACpD,YAAY,CAAE,KAAM,QAAS,EAGzBW,IAAe,MAAM,cAAcA,CAAU,EACjD,MAAMG,EAAM,GACZH,EAAa,YAAY,IAAMI,EAAS,EAAID,CAAG,EAAG,KAAK,MAAM,IAAOA,CAAG,CAAC,CAC5E,OAASE,EAAU,CACf,YAAY,CAAE,KAAM,QAAS,QAAS,OAAOA,CAAG,EAAG,CACvD,CAER,EAEA,SAASD,EAASE,EAAY,CAG1B,GAAI,GAACP,GAAS,CAACV,GAEf,GAAI,CAEA,QAAQ,MAAMU,EAAM,QAASb,EAAW,MAAO,CAAC,EAGhD,KAAM,CAAE,OAAAY,GAAWC,EAEnB,QAASQ,EAAI,EAAGA,EAAIlB,EAAUkB,IACtBT,EAAOS,CAAC,EAMhB,QAAQ,MAAMR,EAAM,QAASb,EAAW,MAAO,CAAC,CACpD,OAASmB,EAAU,CAEf,YAAY,CAAE,KAAM,QAAS,QAAS,OAAOA,CAAG,EAAG,EAE/CL,IAAe,OACf,cAAcA,CAAU,EACxBA,EAAa,KAErB,CACJ"}